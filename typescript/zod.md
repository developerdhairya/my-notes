# Checagem de tipos em runtime com Zod

> Curso original: https://www.totaltypescript.com/tutorials/zod/number

> Exemplos [na pasta Zod](./zod)
## O que √© o Zod

[Zod](https://www.npmjs.com/package/zod) √© uma biblioteca para checagem de tipos em runtime com TypeScript. Diferentemente do TypeScript, que checa os tipos em n√≠vel de desenvolvimento, ou seja, durante o c√≥digo at√© o momento da build, o Zod faz a checagem de tipos em runtime, durante a execu√ß√£o da aplica√ß√£o.

Isso nos d√° o poder de fazer com que nossos tipos sejam validados durante a execu√ß√£o da aplica√ß√£o e possamos manter a seguran√ßa deles mesmo depois de termos passado do momento de desenvolvimento. Transformando o c√≥digo em algo muito mais seguro e f√°cil de manter.

Diferentemente de outras bibliotecas como o JOI, que faz a valida√ß√£o de dados de entrada ou de qualquer tipo de objeto contra um schema, o Zod tamb√©m gera tipos em tempo real, dessa forma temos a valida√ß√£o em runtime refletindo o que a valida√ß√£o em desenvolvimento est√° dizendo e vice-versa.

## Checagem de tipos b√°sica

Imagina que temos a seguinte fun√ß√£o

```ts
export const toString = (num: unknown) => {
  return String(num);
};
```

Aqui temos um valor que est√° tipado como `unknown` j√° que n√£o sabemos qual ser√° o tipo dele, isso significa que podemos chamar o `toString()` com qualquer tipo que quisermos:

```ts
toString("string");
toString(null);
toString(undefined);
toString({ obj: 1 });
toString(1);
```

E isso n√£o vai ser um problema, mas queremos garantir que isso n√£o aconte√ßa durante a execu√ß√£o, para isso podemos fazer uma checagem de tipos com o Zod dentro da fun√ß√£o:

```ts
import { z } from "zod";

export const toString = (num: unknown) => {
  const parsed = z.number().parse(num);
  return String(parsed);
};
```

Caso esse valor n√£o seja um n√∫mero, vamos ter um erro, que podemos testar inclusive com esse c√≥digo:

```ts
// CODE
import { expect, it } from "vitest";
import { z } from "zod";

export const toString = (num: unknown) => {
  const parsed = z.number().parse(num);
  return String(parsed);
};

// TESTS

it("Should throw a runtime error when called with not a number", () => {
  expect(() => toString("123")).toThrowError(
    "Expected number, received string"
  );
});

it("Should return a string when called with a number", () => {
  expect(toString(1)).toBeTypeOf("string");
});
```

E a parte interessante √© que o tipo de retorno da fun√ß√£o ir√° mudar para `string` j√° que o `z.number()` garante que o valor que ser√° passado para a fun√ß√£o ser√° um n√∫mero.

## Tipando retornos de API

Um outro exemplo interessante √© quando temos uma fun√ß√£o que faz uma requisi√ß√£o para uma API e retorna um objeto, por exemplo:

```ts
// CODE

import { expect, it } from "vitest";
import { z } from "zod";

const PersonResult = z.unknown();
//                   ^ üïµÔ∏è‚Äç‚ôÇÔ∏è

export const fetchStarWarsPersonName = async (id: string) => {
  const data = await fetch("https://swapi.dev/api/people/" + id).then((res) =>
    res.json()
  );

  const parsedData = PersonResult.parse(data);

  return parsedData.name;
};

// TESTS

it("Should return the name", async () => {
  expect(await fetchStarWarsPersonName("1")).toEqual("Luke Skywalker");
  expect(await fetchStarWarsPersonName("2")).toEqual("C-3PO");
});
```

Aqui temos um objeto que n√£o sabemos o tipo, mas sabemos que ele tem um campo chamado `name`, ent√£o podemos tipar o objeto com o `z.unknown()` e depois fazer a checagem de tipos com o `PersonResult.parse(data)`. Mas o tipo ser√° `unknown` e n√£o podemos retornar esse tipo de objeto. Para podermos tipar a API propriamente dita, podemos fazer o seguinte:

```ts
// CODE
import { expect, it } from "vitest";
import { z } from "zod";

const PersonResult = z.object({
  name: z.string(),
});
//                   ^ üïµÔ∏è‚Äç‚ôÇÔ∏è

export const fetchStarWarsPersonName = async (id: string) => {
  const data = await fetch("https://swapi.dev/api/people/" + id).then((res) =>
    res.json()
  );

  const parsedData = PersonResult.parse(data);

  return parsedData.name;
};
```

Agora o tipo de retorno da fun√ß√£o ser√° `string` e n√£o `unknown` e podemos usar o `parsedData.name` sem problemas. Al√©m disso, se printarmos a vari√°vel `data` vamos ver que o retorno da API √©, na verdade, muito maior do que o que estamos tipando. O que acontece √© que o Zod vai remover todos os tipos que n√£o forem condizentes com o `schema`, ou seja, se tivermos um campo que n√£o est√° no schema, ele ser√° removido. Por isso que, quando colocamos `name` no schema, vamos ter o `name` no retorno se ele existir na API.

## Arrays

Outro exemplo interessante √© quando temos um array de objetos, por exemplo:

```ts
const StarWarsPerson = z.object({
  name: z.string(),
})

const StarWarsPeopleResults = z.unknown()

export const fetchStarWarsPeople = async () => {
  const data = await fetch("https://swapi.dev/api/people/").then((res) =>
    res.json(),
  )

  const parsedData = StarWarsPeopleResults.parse(data)

  return parsedData.results
}
```

√â o mesmo exemplo anterior, mas agora temos um array de pessoas com a propriedade `name` dentro de uma outra chave `results`, para isso podemos usar um tipo do Zod como tipo principal

```ts
const StarWarsPerson = z.object({
  name: z.string(),
})

const StarWarsPeopleResults = z.object({
  results: z.array(StarWarsPerson)
})

export const fetchStarWarsPeople = async () => {
  const data = await fetch("https://swapi.dev/api/people/").then((res) =>
    res.json(),
  )

  const parsedData = StarWarsPeopleResults.parse(data)

  return parsedData.results
}
```

Agora temos um objeto `StarWarsPerson` que √© um objeto simples, e outro objeto `StarWarsPeopleResults` que √© um objeto que tem um campo `results` que √© um array de `StarWarsPerson`, e podemos usar os tipos do Zod, ou seja, o schema que criamos anteriormente para o `StarWarsPerson` para poder incluir dentro do tipo do `StarWarsPeopleResults`.

## Inferindo e extraindo tipos

Tudo √© muito bacana quando estamos fazendo a tipagem em termos de c√≥digo, mas e quando queremos usar esses tipos em outros lugares? Por exemplo, se quisermos usar o tipo de `StarWarsPerson` em outro lugar? Tipo aqui:

```ts
// CODE

import { z } from "zod";

const StarWarsPerson = z.object({
  name: z.string(),
});

const StarWarsPeopleResults = z.object({
  results: z.array(StarWarsPerson),
});

const logStarWarsPeopleResults = (data: unknown) => {
  //                                    ^ üïµÔ∏è‚Äç‚ôÇÔ∏è
  data.results.map((person) => {
    console.log(person.name);
  });
};
```

Aqui temos uma fun√ß√£o que recebe um objeto `unknown` e tenta fazer um `map` nele, mas o objeto `unknown` n√£o tem o campo `results` e nem o campo `name` e o TypeScript vai reclamar. Para podermos usar o tipo de `StarWarsPerson` em outro lugar, podemos usar o `z.infer`:

```ts
// CODE
import { z } from "zod"

const StarWarsPerson = z.object({
  name: z.string(),
})

const StarWarsPeopleResults = z.object({
  results: z.array(StarWarsPerson),
})

const logStarWarsPeopleResults = (data: z.infer<typeof StarWarsPeopleResults>) => {
  data.results.map((person) => {
    console.log(person.name)
  })
}
```

O que acontece √© que podemos usar o `z.infer` para inferir o tipo de um schema e usar esse tipo em outro lugar. O `z.infer` recebe um `schema` e retorna o tipo do schema. No nosso caso, o `z.infer<typeof StarWarsPeopleResults>` vai retornar o tipo do `StarWarsPeopleResults` que √© um objeto que tem um campo `results` que √© um array de `StarWarsPerson`. Essa "fun√ß√£o" do Zod n√£o √© bem uma fun√ß√£o, mas sim um tipo exportado que vai inferir o tipo interno do schema.

## Opcionais

Outro exemplo interessante √© quando temos um campo opcional, por exemplo:

```ts
import { z } from "zod";

const Form = z.object({
  name: z.string(),
  phoneNumber: z.string(),
  //                     ^ üïµÔ∏è‚Äç‚ôÇÔ∏è
});

export const validateFormInput = (values: unknown) => {
  const parsedData = Form.parse(values);

  return parsedData;
};
```

Nesse exemplo estamos simulando um formul√°rio no front-end, como podemos fazer para que o nosso n√∫mero de telefone seja opcional e n√£o tenha nenhum erro quando n√£o passarmos ele para a API? Para isso podemos usar o `z.optional`:

```ts
const Form = z.object({
  name: z.string(),
  phoneNumber: z.string().optional(),
})

export const validateFormInput = (values: unknown) => {
  const parsedData = Form.parse(values)

  return parsedData
}
```

